"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
/* eslint-disable no-console,no-underscore-dangle,@typescript-eslint/no-non-null-assertion */
const models_1 = require("qaseio/dist/src/models");
const cucumber_1 = require("@cucumber/cucumber");
const qaseio_1 = require("qaseio");
const chalk_1 = __importDefault(require("chalk"));
const fs_1 = __importDefault(require("fs"));
const messages_1 = require("@cucumber/messages/dist/src/messages");
const moment_1 = __importDefault(require("moment"));
const path_1 = __importDefault(require("path"));
var Status = messages_1.io.cucumber.messages.TestStepFinished.TestStepResult.Status;
const StatusMapping = {
    [Status.PASSED]: models_1.ResultStatus.PASSED,
    [Status.FAILED]: models_1.ResultStatus.FAILED,
    [Status.SKIPPED]: models_1.ResultStatus.SKIPPED,
    [Status.AMBIGUOUS]: null,
    [Status.PENDING]: null,
    [Status.UNDEFINED]: null,
    [Status.UNKNOWN]: null,
};
const loadJSON = (file) => {
    try {
        const data = fs_1.default.readFileSync(file, { encoding: 'utf8' });
        if (data) {
            return JSON.parse(data);
        }
    }
    catch (error) {
        // Ignore error when file does not exist or it's malformed
    }
    return undefined;
};
const prepareConfig = (options = {}, configFile = '.qaserc') => {
    const loaded = loadJSON(path_1.default.join(process.cwd(), configFile || '.qaserc'));
    if (!loaded) {
        // eslint-disable-next-line no-throw-literal
        console.log(chalk_1.default `{bold {blue qase:}} {red Missing .qaserc file}`);
    }
    const config = Object.assign(loaded || {}, options);
    return {
        enabled: process.env.QASE_ENABLED === 'true' || config.enabled || false,
        apiToken: process.env.QASE_API_TOKEN || config.apiToken,
        projectCode: process.env.QASE_PROJECT || config.projectCode || '',
        runId: process.env.QASE_RUN_ID || config.runId || '',
        runName: process.env.QASE_RUN_NAME ||
            config.runName ||
            'Automated Run %DATE%',
        runDescription: process.env.QASE_RUN_DESCRIPTION || config.runDescription,
        logging: process.env.QASE_LOGGING !== '' || config.logging,
    };
};
const prepareReportName = (config) => {
    const date = moment_1.default().format();
    return config.runName
        .replace('%DATE%', date);
};
const verifyConfig = (config) => {
    const { enabled, apiToken, projectCode } = config;
    if (enabled) {
        if (!projectCode) {
            console.log(chalk_1.default `{bold {blue qase:}} {red Project Code should be provided}`);
        }
        if (apiToken && projectCode) {
            return true;
        }
    }
    return false;
};
class QaseReporter extends cucumber_1.Formatter {
    constructor(options) {
        var _a;
        super(options);
        this.pickleInfo = {};
        this.testCaseStarts = {};
        this.testCaseStartedResult = {};
        this.testCaseStartedErrors = {};
        this.testCaseScenarioId = {};
        this.pending = [];
        this.results = [];
        this.shouldPublish = 0;
        this.config = prepareConfig(options.parsedArgvOptions, (_a = options.parsedArgvOptions) === null || _a === void 0 ? void 0 : _a.qaseConfig);
        this.enabled = verifyConfig(this.config);
        this.api = new qaseio_1.QaseApi(this.config.apiToken);
        if (!this.enabled) {
            return;
        }
        this.config.runName = prepareReportName(this.config);
        options.eventBroadcaster
            .on('envelope', (envelope) => {
            var _a, _b;
            if (envelope.pickle) {
                this.pickleInfo[envelope.pickle.id] = {
                    tags: this.extractIds(envelope.pickle.tags), name: envelope.pickle.name,
                };
            }
            else if (envelope.testRunStarted) {
                this.checkProject(this.config.projectCode, (prjExists) => {
                    if (prjExists) {
                        this._log(chalk_1.default `{green Project ${this.config.projectCode} exists}`);
                        const willRun = Object.keys(this.pickleInfo).length !== 0;
                        if (this.config.runId && willRun) {
                            this.saveRunId(this.config.runId);
                            this.checkRun(this.config.runId, (runExists) => {
                                const run = this.config.runId;
                                if (runExists) {
                                    this._log(chalk_1.default `{green Using run ${run} to publish test results}`);
                                }
                                else {
                                    this._log(chalk_1.default `{red Run ${run} does not exist}`);
                                }
                            });
                        }
                        else if (!this.config.runId && willRun) {
                            this.createRun(this.config.runName, this.config.runDescription, (created) => {
                                if (created) {
                                    this.saveRunId(created.id);
                                    this._log(
                                    // eslint-disable-next-line max-len
                                    chalk_1.default `{green Using run ${this.config.runId} to publish test results}`);
                                }
                                else {
                                    this._log(
                                    // eslint-disable-next-line max-len
                                    chalk_1.default `{red Could not create run in project ${this.config.projectCode}}`);
                                }
                            });
                        }
                        else if (!willRun) {
                            this._log(chalk_1.default `{red No cases would be executed}`);
                        }
                    }
                    else {
                        this._log(chalk_1.default `{red Project ${this.config.projectCode} does not exist}`);
                    }
                });
            }
            else if (envelope.testRunFinished) {
                if (this.results.length === 0 && this.shouldPublish === 0) {
                    this._log('No testcases were matched. Ensure that your tests are declared correctly.');
                }
                if (envelope.testRunFinished.success) {
                    this._log('Finished success');
                }
                else {
                    this._log('Finished with errors');
                }
            }
            else if (envelope.testCase) {
                this.testCaseScenarioId[envelope.testCase.id] = envelope.testCase.pickleId;
            }
            else if (envelope.testCaseStarted) {
                this.testCaseStarts[envelope.testCaseStarted.id] = envelope.testCaseStarted;
                this.testCaseStartedResult[envelope.testCaseStarted.id] = models_1.ResultStatus.PASSED;
            }
            else if (envelope.testStepFinished) {
                const stepFin = envelope.testStepFinished;
                const stepStatus = stepFin.testStepResult.status;
                const stepMessage = stepFin.testStepResult.message;
                const oldStatus = this.testCaseStartedResult[stepFin.testCaseStartedId];
                const newStatus = StatusMapping[stepFin.testStepResult.status];
                if (newStatus === null) {
                    this._log(
                    // eslint-disable-next-line max-len
                    chalk_1.default `{redBright Unexpected finish status ${stepStatus} received for step ${stepMessage}}`);
                    return;
                }
                if (newStatus !== models_1.ResultStatus.PASSED) {
                    this.addErrorMessage(stepFin.testCaseStartedId, (_a = stepFin.testStepResult) === null || _a === void 0 ? void 0 : _a.message);
                    if (oldStatus) {
                        if (oldStatus !== models_1.ResultStatus.FAILED && newStatus) {
                            this.testCaseStartedResult[stepFin.testCaseStartedId] = newStatus;
                        }
                    }
                    else {
                        if (newStatus) {
                            this.testCaseStartedResult[stepFin.testCaseStartedId] = newStatus;
                        }
                    }
                }
            }
            else if (envelope.testCaseFinished) {
                const tcs = this.testCaseStarts[envelope.testCaseFinished.testCaseStartedId];
                const pickleId = this.testCaseScenarioId[tcs.testCaseId];
                const info = this.pickleInfo[pickleId];
                const status = this.testCaseStartedResult[envelope.testCaseFinished.testCaseStartedId];
                const test = {
                    name: info.name,
                    started: tcs,
                    finished: envelope.testCaseFinished,
                    tags: info.tags,
                    // eslint-disable-next-line max-len, @typescript-eslint/no-unnecessary-type-assertion
                    duration: Math.abs((envelope.testCaseFinished.timestamp.seconds - tcs.timestamp.seconds)),
                    error: (_b = this.testCaseStartedErrors[tcs.id]) === null || _b === void 0 ? void 0 : _b.join('\n\n'),
                };
                this.publishCaseResult(test, status);
            }
            else if (envelope.parseError) {
                console.log('Error:', envelope.parseError);
            }
        });
    }
    addErrorMessage(tcsid, error) {
        if (error) {
            if (tcsid in this.testCaseStartedErrors) {
                this.testCaseStartedErrors[tcsid].push(error);
            }
            else {
                this.testCaseStartedErrors[tcsid] = [error];
            }
        }
    }
    _log(message, ...optionalParams) {
        if (this.config.logging) {
            console.log(chalk_1.default `{bold {blue qase:}} ${message}`, ...optionalParams);
        }
    }
    checkProject(projectCode, cb) {
        this.api.projects.exists(projectCode)
            .then(cb)
            .catch((err) => {
            this._log(err);
        });
    }
    createRun(name, description, cb) {
        this.api.runs.create(this.config.projectCode, new models_1.RunCreate(name || `Automated run ${new Date().toISOString()}`, [], { description: description || 'Cypress automated run' }))
            .then((res) => res.data)
            .then(cb)
            .catch((err) => {
            this._log(`Error on creating run ${err}`);
        });
    }
    checkRun(runId, cb) {
        if (runId !== undefined) {
            this.api.runs.exists(this.config.projectCode, runId)
                .then(cb)
                .catch((err) => {
                this._log(`Error on checking run ${err}`);
            });
        }
        else {
            cb(false);
        }
    }
    saveRunId(runId) {
        this.config.runId = runId;
        if (this.config.runId) {
            while (this.pending.length) {
                this._log(`Number of pending: ${this.pending.length}`);
                const cb = this.pending.shift();
                if (cb) {
                    cb(this.config.runId);
                }
            }
        }
    }
    logTestItem(name, status) {
        const map = {
            failed: chalk_1.default `{red Test ${name} ${status}}`,
            passed: chalk_1.default `{green Test ${name} ${status}}`,
            pending: chalk_1.default `{blueBright Test ${name} ${status}}`,
        };
        if (status) {
            this._log(map[status]);
        }
    }
    publishCaseResult(test, status) {
        this.logTestItem(test.name, status);
        const caseIds = test.tags;
        caseIds.forEach((caseId) => {
            this.shouldPublish++;
            const publishTest = (runId) => {
                if (caseId) {
                    const add = caseIds.length > 1 ? chalk_1.default ` {white For case ${caseId}}` : '';
                    this._log(chalk_1.default `{gray Start publishing: ${test.name}}${add}`);
                    const result = new models_1.ResultCreate(parseInt(caseId, 10), status, {
                        time: test.duration,
                        stacktrace: test.error,
                        comment: test.error ? test.error.split('\n')[0] : undefined,
                    });
                    this.api.results.create(this.config.projectCode, runId, result)
                        .then((res) => {
                        this.results.push({ test, result: res.data });
                        this._log(chalk_1.default `{gray Result published: ${test.name} ${res.data.hash}}${add}`);
                        this.shouldPublish--;
                    })
                        .catch((err) => {
                        this._log(err);
                        this.shouldPublish--;
                    });
                }
            };
            if (this.config.runId) {
                publishTest(this.config.runId);
            }
            else {
                this.pending.push(publishTest);
            }
        });
    }
    extractIds(tagsList) {
        const regex = /[Qq]-*(\d+)/;
        return tagsList.filter((tagInfo) => regex.test(tagInfo.name)).map((tagInfo) => regex.exec(tagInfo.name)[1]);
    }
}
module.exports = QaseReporter;
//# sourceMappingURL=index.js.map